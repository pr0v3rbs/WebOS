//<MStar Software>//******************************************************************************// MStar Software// Copyright (c) 2010 - 2012 MStar Semiconductor, Inc. All rights reserved.// All software, firmware and related documentation herein ("MStar Software") are// intellectual property of MStar Semiconductor, Inc. ("MStar") and protected by// law, including, but not limited to, copyright law and international treaties.// Any use, modification, reproduction, retransmission, or republication of all// or part of MStar Software is expressly prohibited, unless prior written// permission has been granted by MStar.//// By accessing, browsing and/or using MStar Software, you acknowledge that you// have read, understood, and agree, to be bound by below terms ("Terms") and to// comply with all applicable laws and regulations://// 1. MStar shall retain any and all right, ownership and interest to MStar//    Software and any modification/derivatives thereof.//    No right, ownership, or interest to MStar Software and any//    modification/derivatives thereof is transferred to you under Terms.//// 2. You understand that MStar Software might include, incorporate or be//    supplied together with third party`s software and the use of MStar//    Software may require additional licenses from third parties.//    Therefore, you hereby agree it is your sole responsibility to separately//    obtain any and all third party right and license necessary for your use of//    such third party`s software.//// 3. MStar Software and any modification/derivatives thereof shall be deemed as//    MStar`s confidential information and you agree to keep MStar`s//    confidential information in strictest confidence and not disclose to any//    third party.//// 4. MStar Software is provided on an "AS IS" basis without warranties of any//    kind. Any warranties are hereby expressly disclaimed by MStar, including//    without limitation, any warranties of merchantability, non-infringement of//    intellectual property rights, fitness for a particular purpose, error free//    and in conformity with any international standard.  You agree to waive any//    claim against MStar for any loss, damage, cost or expense that you may//    incur related to your use of MStar Software.//    In no event shall MStar be liable for any direct, indirect, incidental or//    consequential damages, including without limitation, lost of profit or//    revenues, lost or damage of data, and unauthorized system use.//    You agree that this Section 4 shall still apply without being affected//    even if MStar Software has been modified by MStar in accordance with your//    request or instruction for your use, except otherwise agreed by both//    parties in writing.//// 5. If requested, MStar may from time to time provide technical supports or//    services in relation with MStar Software to you for your use of//    MStar Software in conjunction with your or your customer`s product//    ("Services").//    You understand and agree that, except otherwise agreed by both parties in//    writing, Services are provided on an "AS IS" basis and the warranty//    disclaimer set forth in Section 4 above shall apply.//// 6. Nothing contained herein shall be construed as by implication, estoppels//    or otherwise://    (a) conferring any license or right to use MStar name, trademark, service//        mark, symbol or any other identification;//    (b) obligating MStar or any of its affiliates to furnish any person,//        including without limitation, you and your customers, any assistance//        of any kind whatsoever, or any information; or//    (c) conferring any license or right under any intellectual property right.//// 7. These terms shall be governed by and construed in accordance with the laws//    of Taiwan, R.O.C., excluding its conflict of law rules.//    Any and all dispute arising out hereof or related hereto shall be finally//    settled by arbitration referred to the Chinese Arbitration Association,//    Taipei in accordance with the ROC Arbitration Law and the Arbitration//    Rules of the Association by three (3) arbitrators appointed in accordance//    with the said Rules.//    The place of arbitration shall be in Taipei, Taiwan and the language shall//    be English.//    The arbitration award shall be final and binding to both parties.////******************************************************************************//<MStar Software>///////////////////////////////////////////////////////////////////////////////////////////////////////// @file   Mapi_mhl.h/// @author MStar Semiconductor Inc./// @brief  MHL driver Function////////////////////////////////////////////////////////////////////////////////////////////////////*    1. Check whether MHL cable is plugged or not in Rx side    2. Disable R-term and output Vbus    3. Check whether Cbus is connected(discovery pulse completed)    4. Sink -> Source: "SET_HPD"    5. Sink -> Source: Write_Stat - "DCAP_RDY" and Write_INT - "DCAP_CHG"    6. Sink -> Source: Write_Stat - "PATH_EN"*/#ifndef _MDRV_MHL_ST_H_#define _MDRV_MHL_ST_H_#include "MsTypes.h"#include "MsCommon.h"#ifdef __cplusplusextern "C"{#endif//-------------------------------------------------------------------------------------------------//  Define//-------------------------------------------------------------------------------------------------#define MODIFY_FOR_LG_LAYOUT                0#define DMHL_INT_ENABLE                     0 // MHL interrupt enable#define DMHL_CTS                            1 // MHL setting for CTS#define DMHL_TIMER_POLLING_COUNTER          0#define DMHL_TIMER_POLLING_INTERVAL         (!DMHL_TIMER_POLLING_COUNTER)#define DEM_POLLING_DELAY                   10U     // Main Loop Polling interval (ms)#define CBUS_COMMAND_TIMEOUT_SECS           2U      // No response for 1 second means we hold off and move#define CBUS_ABORT_PADING_SECS              2U      // Allow bus to quieten down when ABORTs are received.#define CBUS_TIMER_CONTROL_MASK             32768U#define CBUS_TIMER_SECOND_COUNT             1010U#define CBUS_MSC_WAIT_TIME_MS               150U#define CBUS_SWITCH_MUX_TIME_MS             3500U#define CBUS_POLLING_TIMER_INTERVAL         10U // Unit ms#define CBUS_WAIT_MSC_RESPONSE_INTERVAL     101U // 10ms one unit#define CBUS_MSG_RCP_RELEASE_INTERVAL       15U // 10ms one unit#define CBUS_CHECK_CONTENT_ON_INTERVAL      101U // 10ms one unit#define DMHL_ADOPTER_ID                     0x02CBU // Mstar: 715#define DMHL_DEVICE_ID                      0x0000U // Chip ID?#define DMHL_VENDOR_ID                      0x00U // ?#define MHL_DEVICE_CAPABILITY_SIZE          16U#define MHL_XDEVICE_CAPABILITY_SIZE         4U#define MHL_MSC_SCRATCHPAD_SIZE             16U#define MHL_CBUS_DATA_SIZE                  (MHL_MSC_SCRATCHPAD_SIZE +2) // offset + maxi 16 packets#define DMHL_CBUS_TX_FIFO                   (MHL_MSC_SCRATCHPAD_SIZE +3) // Write_Burst(0x6C) + offset(0x40 ~ 0x7F) + maxi 16 packets + EOF(0x32)#define MHL_CBUS_TX_QUEUE_NUM               3U#define MHL_CBUS_TOTAL_QUEUE_NUM            ((MHL_CBUS_TX_QUEUE_NUM > 0)?(MHL_CBUS_TX_QUEUE_NUM +1):2)#define MHL_CBUS_RX_QUEUE_INDEX             (MHL_CBUS_TOTAL_QUEUE_NUM -1)#define MHL_EMSC_DATA_SIZE                  256U#define MHL_EMSC_DATA_SIZE_THRESHOLD        150U#define DMHL_CTS_HDCP_PATCH                 DISABLE// for CTS HDCP 2C-04#define DMHL_LG_PRADA_PATCH                 ENABLE// for LG PRADA patch#define DMHL_IGNORE_USB_PULSE_PATCH         ENABLE // for ignore USB pulse patch#define DMHL_DE_UNSTABLE_PATCH              ENABLE#define DMHL_WAKE_UP_PULSE_INT              ENABLE#define DMHL_CTS_SEND_MSC                   ENABLE#define DMHL_TEST_HDCP_SOFTWARE_PATCH       ENABLE#define DMHL_AUTO_SENT_RAP_POLLING          DISABLE#define DMHL_TEST_SIGNAL_SUPPORT            DISABLE#define MHL_INPUT_PORT(a)                   (a +65)#define MASKSET(a, b, c)                    ((a &~c) | (b &c))#define ABS_MINUS(a, b)                     ((a > b)? (a -b): (b -a))#define GET_BIT(a)                          (((a) > 0)? 1: 0)#define MHL_EDID_BLOCK_LENGTH               128U#define MHL_EDID_DTD_LENGTH                 18U#define MHL_EDID_FIRST_DTD_START            0x36U#define MHL_EDID_SECOND_DTD_START           0x48U#define MHL_EDID_EXTENSION_FLAG             0x7EU  #define MHL_EDID_RESERVED_DATA_BLOCK        0x82U#define MHL_3D_SEQUENCE_LENGTH              5U#define MHL_3D_ITEM_LENGTH                  2U#define MHL_3D_DTD_INFORMATION_LENGTH       8U#define MHL_3D_VIC_INFORMATION_LENGTH       16U#define MHL_VC_SEQUENCE_LENGTH              3U#define MHL_VC_ITEM_LENGTH                  3U#define MHL_VIRTUAL_CHANNEL_LENGTH          7U#define MHL_CBUS1_TIME_SLOT_DEFAULT         1U#define MHL_EMSC_TIME_SLOT_DEFAULT          4U#define MHL_ECBUS_S_TIME_SLOT_TOTAL         25U#define MHL_CBUS_SLOT_NOT_ALLOCATE          0xFFU#define MHL_HEV_VIC_SEQUENCE_LENGTH         5U#define MHL_HEV_VIC_ITEM_LENGTH             2U#define MHL_HEV_VIC_TOTAL_ENTRY             3U#define MHL_HEV_VIC_INDEX0                  0x5DU#define MHL_HEV_VIC_INDEX1                  0x5EU#define MHL_HEV_VIC_INDEX2                  0x5FU#define MHL_HEV_VIC_INDEX3                  0x62U#define MHL_HEV_VIC_INDEX4                  0x63U#define MHL_HEV_VIC_INDEX5                  0x64U#define MHL_HEV_DTD_SEQUENCE_LENGTH         1U#define MHL_HEV_DTD_TOTAL_ENTRY             1U#define MHL_AUDIO_TUNNEL_SEQUENCE_LENGTH    3U#define MHL_AUDIO_TUNNEL_ITEM_LENGTH        3U#define MHL_AUDIO_TUNNEL_SAD_RNTRY          1U // Short audio descriptors#define MHL_AUDIO_TUNNEL_SADB_RNTRY         0U // Speaker allocation data block#define MHL_AUDIO_TUNNEL_TOTAL_ENTRY        (MHL_AUDIO_TUNNEL_SAD_RNTRY +MHL_AUDIO_TUNNEL_SADB_RNTRY)#define MHL_AUDIO_TUNNEL_INDEX0             0UL#define MHL_AUDIO_TUNNEL_INDEX1             0UL#define MHL_AUDIO_TUNNEL_INDEX2             0UL#define MHL_AUDIO_TUNNEL_INDEX3             0UL#define MHL_AUDIO_TUNNEL_INDEX4             0UL#define MHL_AUDIO_TUNNEL_INDEX5             0UL#define MHL_EMSC_SUPPORT_SEQUENCE_LENGTH    5U#define MHL_EMSC_SUPPORT_ITEM_LENGTH        2U#define MHL_EMSC_SUPPORT_TOTAL_ENTRY        1U#define MHL_EMSC_SUPPORT_BURST_ID0          0x0062U // MHL_BURST_ID_HID_PAYLOAD#define MHL_EMSC_SUPPORT_BURST_ID1          0U#define MHL_EMSC_SUPPORT_BURST_ID2          0U#define MHL_EMSC_SUPPORT_BURST_ID3          0U#define MHL_EMSC_SUPPORT_BURST_ID4          0U#define MHL_EMSC_SUPPORT_BURST_ID5          0U#define MHL_ADOPTER_ID_ROKU                 0x0411U#define MHL_ADOPTER_ID_HTC                  0x016FU#define MHL_DEVICE_ID_HTC                   0x0000U//-------------------------------------------------------------------------------------------------//  Type and Structure//-------------------------------------------------------------------------------------------------typedef enum{    CBUS_STATE_IDLE = 0,    // Cbus idle    CBUS_STATE_SENT,    // Cbus command sent    CBUS_STATE_ACK,    // Cbus command has been acked    CBUS_STATE_RECEIVED,    // Cbus message received    CBUS_STATE_WAITING_ACK,    // Cbus waiting RCPK or PAPK} CbusState_T;typedef enum{    CBUS_REQ_IDLE       = 0,    CBUS_REQ_PENDING,           // Request is waiting to be sent    CBUS_REQ_SENT,              // Request has been sent    CBUS_REQ_RECEIVED,          // Request data has been received} CbusReqState_T;enum CBUS_HEADER_TYPE{    DDC_HEADER = 0,    VENDER_HEADER,    MSC_HEADER,};enum CBUS_CONTROL_TYPE{    CBUS_DATA = 0,    CBUS_CONTROL,};enum CBUS_RECEIVE_STATE_TYPE{    CBUS_RECEIVE_NORMAL = 0,    CBUS_RECEIVE_TIMEOUT,};enum CBUS_CLOCK_MODE_TYPE{    CBUS_CLOCK_RESERVED = 0,    CBUS_CLOCK_PACKET_PIXEL = 2,    CBUS_CLOCK_NORMAL_24BIT,};enum MHL_VIEW_PIXEL_FORMATE_TYPE{    MHL_VIEW_PIXEL_FORMATE_24BPP = 0,    MHL_VIEW_PIXEL_FORMATE_16BPP,};enum VBUS_CONTROL_TYPE{    VBUS_SW_UNCHARGE = 0,    VBUS_HW_DETECT,    VBUS_SW_CHARGE,};enum MHL_3D_SUPPORT_TYPE{    MHL_3D_FS_SUPPORT = BIT(0),    MHL_3D_TB_SUPPORT = BIT(1),    MHL_3D_LR_SUPPORT = BIT(2),};enum MHL_3D_DTD_NUMBER_TYPE{    MHL_3D_FIRST_DTD = 0,    MHL_3D_SECOND_DTD,    MHL_3D_THIRD_DTD,};enum MHL_3D_DTD_STEREO_TYPE{    MHL_3D_DTD_STEREO_NORMAL_DISPLAY = 0,    MHL_3D_DTD_STEREO_FIELD_SEQUENTIAL_RIGHT = 2,    MHL_3D_DTD_STEREO_FIELD_SEQUENTIAL_LEFT = 4,    MHL_3D_DTD_STEREO_2WAY_INTERLEAVED_RIGHT = 3,    MHL_3D_DTD_STEREO_2WAY_INTERLEAVED_LEFT = 5,    MHL_3D_DTD_STEREO_4WAY_INTERLEAVED = 6,    MHL_3D_DTD_STEREO_SIDE_BY_SIDE_INTERLEAVED = 7,};enum MHL_EDID_DATA_BLOCK_CODE_TYPE{    MHL_EDID_AUDIO_DATA_BLOCK_CODE = 1,    MHL_EDID_VIDEO_DATA_BLOCK_CODE = 2,    MHL_EDID_VENDER_SPECIFIC_DATA_BLOCK_CODE = 3,    MHL_EDID_SPEAKER_ALLOCATION_DATA_BLOCK_CODE = 4,    MHL_EDID_VESA_DTC_DATA_BLOCK_CODE = 5,    MHL_EDID_USE_EXTENDED_TAG_BLOCK_CODE = 7,};enum MHL_VIC_PARSING_STATE_TYPE{    MHL_VIC_PARSING_START = 0,    MHL_VIC_PARSING_CHECK_HDMI_VIDEO_PRESENT,    MHL_VIC_PARSING_CHECK_3D_PRESENT,    MHL_VIC_PARSING_CHECK_HDMI_VIC,    MHL_VIC_PARSING_3D_MULTI_PRESENT_00,    MHL_VIC_PARSING_3D_MULTI_PRESENT_01,    MHL_VIC_PARSING_3D_MULTI_PRESENT_10,    MHL_VIC_PARSING_CHECK_3D_STRUCTURE,    MHL_VIC_PARSING_CHECK_3D_PRESENT_TIMING,    MHL_VIC_PARSING_FINISH,};enum MHL_3D_PRESENT_TIMING_VIC_TYPE{    MHL_3D_PRESENT_VIC_1920x1080p24Hz = 32,    MHL_3D_PRESENT_VIC_1280x720p60Hz = 4,    MHL_3D_PRESENT_VIC_1920x1080i60Hz = 5,    MHL_3D_PRESENT_VIC_1280x720p50Hz = 19,    MHL_3D_PRESENT_VIC_1920x1080i50Hz = 20,};typedef enum{    RX_HDMI_RTERM = 0,    // HDMI mode    RX_MHL_RTERM,    // MHL mode    RX_RTERM_OFF,    // R-term off} RXRtermControl_T;enum MHL_CBUS_WRITE_BURST_STATE_TYPE{    MHL_CBUS_WRITE_BURST_NONE = 0,    MHL_CBUS_WRITE_BURST_START,    MHL_CBUS_WRITE_BURST_SEND_REQUEST,    MHL_CBUS_WRITE_BURST_REVEIVE_GRANT,    MHL_CBUS_WRITE_BURST_SEND_DATA,    MHL_CBUS_WRITE_BURST_REVEIVE_REQUEST,    MHL_CBUS_WRITE_BURST_SEND_GRANT,    MHL_CBUS_WRITE_BURST_RECEIVE_DATA,    MHL_CBUS_WRITE_BURST_END,};enum MHL_CBUS_SEND_WRITE_BURST_TYPE{    MHL_CBUS_SEND_WRITE_BURST_NONE = 0,    MHL_CBUS_SEND_WRITE_BURST_USER_DATA,    MHL_CBUS_SEND_WRITE_BURST_3D_INFORMATION,    MHL_CBUS_SEND_WRITE_BURST_VIRTUAL_CHANNEL,    MHL_CBUS_SEND_WRITE_BURST_HIGH_END_VIDEO,    MHL_CBUS_SEND_WRITE_BURST_AUDIO_DATA_TUNNEL,    MHL_CBUS_SEND_WRITE_BURST_EMSC_DATA_TUNNEL,    MHL_CBUS_SEND_WRITE_BURST_BIST_RETURN_STATUS,};enum MHL_CBUS_RUSB_PROCESS_STATE_TYPE{    MHL_CBUS_RUSB_NONE = 0,    MHL_CBUS_RUSB_START,    MHL_CBUS_RUSB_SOURCE_HOST,    MHL_CBUS_RUSB_REQUEST_HOST,    MHL_CBUS_RUSB_SINK_HOST,    MHL_CBUS_RUSB_RELINQUISH,    MHL_CBUS_RUSB_END,};enum MHL_CBUS_RHID_PROCESS_STATE_TYPE{    MHL_CBUS_RHID_NONE = 0,    MHL_CBUS_RHID_START,    MHL_CBUS_RHID_SOURCE_HOST,    MHL_CBUS_RHID_REQUEST_HOST,    MHL_CBUS_RHID_SINK_HOST,    MHL_CBUS_RHID_RELINQUISH,    MHL_CBUS_RHID_END,};enum MHL_CBUS_BIST_PROCESS_STATE_TYPE{    MHL_CBUS_BIST_NONE = 0,    MHL_CBUS_BIST_RECEIVE_SETUP,    MHL_CBUS_BIST_WAIT_TRIGGER,    MHL_CBUS_BIST_RECEIVE_TRIGGER,    MHL_CBUS_BIST_ECBUS_SWITCH,    MHL_CBUS_BIST_EVENT_FINISH,    MHL_CBUS_BIST_REQUEST_STATUS,    MHL_CBUS_BIST_RETURN_STATUS,    MHL_CBUS_BIST_END,};enum MHL_CBUS_FEATURE_REQUEST_STATE_TYPE{    MHL_CBUS_FEATURE_NONE = 0,    MHL_CBUS_FEATURE_START,    MHL_CBUS_FEATURE_SEND_3D_INFORMATION,    MHL_CBUS_FEATURE_SEND_HIGH_END_VIDEO,    MHL_CBUS_FEATURE_SEND_AUDIO_DATA_TUNNEL,    MHL_CBUS_FEATURE_SEND_EMSC_DATA_TUNNEL,    MHL_CBUS_FEATURE_SEND_FEATURE_COMPLETE,    MHL_CBUS_FEATURE_SEND_FEATURE_REQUEST,    MHL_CBUS_FEATURE_END,};enum MHL_ECBUS_STATE_TYPE{    MHL_ECBUS_STATE_NONE = 0,    MHL_ECBUS_STATE_RECEIVE_MODE_UP,    MHL_ECBUS_STATE_TRIGGER_MODE_UP = MHL_ECBUS_STATE_RECEIVE_MODE_UP +4,    MHL_ECBUS_STATE_PROCESS_MODE_UP,    MHL_ECBUS_STATE_MODE_UP_CLOCK_LOCK,    MHL_ECBUS_STATE_RECEIVE_MODE_DOWN,    MHL_ECBUS_STATE_TRIGGER_MODE_DOWN = MHL_ECBUS_STATE_RECEIVE_MODE_DOWN +4,    MHL_ECBUS_STATE_PROCESS_MODE_DOWN,    MHL_ECBUS_STATE_STABLE_POLLING,    MHL_ECBUS_STATE_END,};enum MHL_ECBUS_EVENT_TYPE{    MHL_ECBUS_EVENT_NONE = 0,    MHL_ECBUS_EVENT_PREPARE_MODE_UP,    MHL_ECBUS_EVENT_MODE_UP_PROCESS,    MHL_ECBUS_EVENT_PREPARE_MODE_DOWN,    MHL_ECBUS_EVENT_MODE_DOWN_PROCESS,    MHL_ECBUS_EVENT_UNLOCK_RESET,    MHL_ECBUS_EVENT_STUCK_TO_LOW,    MHL_ECBUS_EVENT_ECBUS_COMMAND_PARSING,};enum MHL_ECBUS_STATUS_FLAG_TYPE{    MHL_ECBUS_STATUS_TRAINING_PASS = BIT(0),    MHL_ECBUS_STATUS_CLOCK_LOCK = BIT(1),    MHL_ECBUS_STATUS_SLOT_SYNC_DONE = BIT(2),    MHL_ECBUS_STATUS_EMSC_SYNC_DONE = BIT(3),    MHL_ECBUS_STATUS_RETRY_TIMEOUT = BIT(4),};enum MHL_EMSC_SEND_STATUS_TYPE{    MHL_EMSC_SEND_NONE = 0,    MHL_EMSC_SEND_DATA,    MHL_EMSC_SEND_CHECK,    MHL_EMSC_SEND_PASS,    MHL_EMSC_SEND_FAIL,};enum MHL_ECBUS_TRAINING_STATE_TYPE{    MHL_ECBUS_STATE_DISABLE = 0,    MHL_ECBUS_STATE_WAIT_CLOCK_LOCK,    MHL_ECBUS_STATE_WAIT_SEND_CLOCK,    MHL_ECBUS_STATE_SEND_CLOCK,    MHL_ECBUS_STATE_SEND_COMMA1,    MHL_ECBUS_STATE_RECEIVE_COMMA2,    MHL_ECBUS_STATE_SEND_COMMA2,    MHL_ECBUS_STATE_SOURCE_ACTIVE,    MHL_ECBUS_STATE_ACTIVE,    MHL_ECBUS_STATE_FAIL = 10,    MHL_ECBUS_STATE_TRAINING_NONE,};enum MHL_ECBUS_TRAIN_STATE_TYPE{    MHL_ECBUS_TRAIN_IDLE = 0,    MHL_ECBUS_TRAIN_WAIT_CLOCK_LOCK,    MHL_ECBUS_TRAIN_ADJUST_TXLOC,    MHL_ECBUS_TRAIN_ADJUST_TXLOC_OK,    MHL_ECBUS_TRAIN_DELAY_REVERIFY,    MHL_ECBUS_TRAIN_WAIT_RRCEIVE_COMMA2,    MHL_ECBUS_TRAIN_ADJUST_CAP,    MHL_ECBUS_TRAIN_DONE,    MHL_ECBUS_TRAIN_FAIL,};enum{    MSC_NONE = 0x00,    MSC_ACK = 0x33,                     // Command/Data byte acknowledged    MSC_NACK = 0x34,                    // Command or Data byte not acknowledge    MSC_ABORT = 0x35,                   // Transaction abort    MSC_WRITE_STAT_OR_SET_INT = 0x60,   // Write one status or interrupt register    MSC_READ_DEVCAP = 0x61,             // Read one register    MSC_GET_STATE = 0x62,               // Read CBUS revision level from follower    MSC_GET_VENDOR_ID = 0x63,           // Read vendor ID value from follower.    MSC_SET_HPD = 0x64,                 // Set Hot Plug Detect in follower    MSC_CLR_HPD = 0x65,                 // Clear Hot Plug Detect in follower    MSC_MSC_MSG = 0x68,                 // VS command to send RCP sub-commands    MSC_GET_SC1_ERRORCODE = 0x69,       // Get Vendor-Specific command error code.    MSC_GET_DDC_ERRORCODE = 0x6A,       // Get DDC channel command error code.    MSC_GET_MSC_ERRORCODE = 0x6B,       // Get MSC command error code.    MSC_WRITE_BURST = 0x6C,             // Write 1-16 bytes to responder’s scratchpad.    MSC_GET_SC3_ERRORCODE = 0x6D,       // Get channel 3 command error code.    MSC_WRITE_XSTAT = 0x70,             // Extend write one status    MSC_READ_XDEVCAP = 0x71,            // Extend read device capability    MSC_EOF = 0x32,                     // End of Frame    MSC_RESERVED = 0xFF,}; //MscCtrlPkt_T;enum{    SI_HPD_ACTIVE               = 0x00,     // HPD HI, HDCP, EDID, RX Term enabled    SI_HPD_INACTIVE,                        // HPD LOW, HDCP, RX Term disabled    SI_HPD_ACTIVE_EX,                       // EDID, RX Term enabled    SI_HPD_INACTIVE_EX,                     // HPD HI, HDCP, EDID, RX Term disabled    SI_HPD_TOGGLE,                  // Special use for CBUS connect};enum{    MSC_MSG_MSGE = 0x02,                // MSG Error sub-command    MSC_MSG_RCP = 0x10,                 // RCP sub-command    MSC_MSG_RCPK = 0x11,                // RCP Acknowledge sub-command    MSC_MSG_RCPE = 0x12,                // RCP Error sub-command    MSC_MSG_RAP = 0x20,                 // Mode Change Warning sub-command    MSC_MSG_RAPK = 0x21,                // MCW Acknowledge sub-command    MSC_MSG_RBP = 0x22,                 // Remote Button Protocol sub- command    MSC_MSG_RBPK = 0x23,                // RBP Acknowledge sub-command    MSC_MSG_RBPE = 0x24,                // RBP Error sub-command    MSC_MSG_UCP = 0x30,                 // UCP sub-command    MSC_MSG_UCPK = 0x31,                // UCP Acknowledge sub-command    MSC_MSG_UCPE = 0x32,                // UCP Error sub-command    MSC_MSG_RUSB = 0x40,                // Request USB host role    MSC_MSG_RUSBK = 0x41,               // Acknowledge request for USB host role    MSC_MSG_RHID = 0x42,                // Request HID host role    MSC_MSG_RHIDK = 0x43,               // Acknowledge request for HID host role    MSC_MSG_ATT = 0x50,                 // Request Attention sub-command    MSC_MSG_ATTK = 0x51,                // ATT Acknowledge sub-command    MSC_MSG_BIST_TRIGGRT = 0x60,        // BIST Trigger sub-command    MSC_MSG_BIST_REQUEST_STAT = 0x61,   // BIST Request Status sub-command    MSC_MSG_BIST_READY = 0x62,          // BIST Ready sub-command    MSC_MSG_BIST_STOP = 0x63,           // BIST Stop sub-command    MSC_MSG_SI_UNKNOWN = 0xF0,          // SI used unknow sub-command    MSC_MSG_SI_UNKNOWNK = 0xF1,         // SI used unknow acknowledge sub-command}; //MscMsgSubCmd_T;enum{    MSC_ERRORCODE_NO_ERROR = 0x00,    // Normal response, no error    MSC_ERRORCODE_RETRY_EXCEEDED = 0x01,    // Re-try threshold exceeded    MSC_ERRORCODE_PROTOCOL_ERROR = 0x02,    // Protocol error    MSC_ERRORCODE_PEER_TIMEOUT = 0x04,    // Peer timed out    MSC_ERRORCODE_INVALID_OPCODE = 0x08,    // Invalid op code    MSC_ERRORCODE_BAD_OFFSET = 0x10,    // Bad offset in command    MSC_ERRORCODE_PEER_BUSY = 0x20,    // Peer is busy, can't process new request};enum MHL_MSGE_STATUS_CODE{    MHL_MSGE_NO_ERROR = 0x00,     // MSGE No Error    MHL_MSGE_INVALID_SUB_COMMAND_CODE = 0x01,};enum MHL_RCP_STATUS_CODE{    MHL_RCP_NO_ERROR = 0x00,     // RCP No Error    MHL_RCP_INEFFECTIVE_KEY_CODE = 0x01,     // The key code in the RCP sub-command is not recognized    MHL_RCP_RESPONDER_BUSY = 0x02,     // RCP Response busy};enum MHL_RAP_STATUS_CODE{    MHL_RAP_NO_ERROR = 0x00,     // RAP No Error    MHL_RAP_UNRECOGNIZED_ACTION_CODE = 0x01,    MHL_RAP_UNSUPPORTED_ACTION_CODE = 0x02,    MHL_RAP_RESPONDER_BUSY = 0x03,};enum MHL_UCP_STATUS_CODE{    MHL_UCP_NO_ERROR = 0x00,     // UCP No Error    MHL_UCP_INEFFECTIVE_KEY_CODE = 0x01,     // The key code in the UCP sub-command is not recognized};enum MHL_ATT_STATUS_CODE{    MHL_ATT_NO_ERROR = 0x00,     // ATT No Error    MHL_ATT_UNRECOGNIZED_ACTION_CODE = 0x01,     // The key code in the ATT sub-command is not recognized    MHL_ATT_UNSUPPORTED_ACTION_CODE = 0x02,    MHL_ATT_RESPONDER_BUSY = 0x03,};enum MHL_RBP_STATUS_CODE{    MHL_RBP_NO_ERROR = 0x00,     // RBP No Error    MHL_RBP_INEFFECTIVE_BUTTON_CODE = 0x01,     // The key code in the RBP sub-command is not recognized    MHL_RBP_RESPONDER_BUSY = 0x02,     // RBP Response busy};enum MHL_RUSB_STATUS_CODE{    MHL_RUSB_NO_ERROR = 0x00,     // RUSB No Error    MHL_RUSB_INVALID_CODE = 0x01,        MHL_RUSB_DENY = 0x02,     };enum MHL_RHID_STATUS_CODE{    MHL_RHID_NO_ERROR = 0x00,     // RHID No Error    MHL_RHID_INVALID_CODE = 0x01,        MHL_RHID_DENY = 0x02,     };enum MHL_BIST_REQ_KEY_TYPE{    MHL_BIST_REQ_NOTHING = 0x00,    MHL_BIST_REQ_RETURN_STATUS = 0x01,};enum MHL_VC_FEATURE_ID_TYPE{    MHL_VC_FEATURE_ID_EMSC = 0x00,    MHL_VC_FEATURE_ID_USB = 0x01,    MHL_VC_FEATURE_ID_AUDIO = 0x02,    MHL_VC_FEATURE_ID_IP_PACKET = 0x03,    MHL_VC_FEATURE_ID_COMPRESSED_VIDEO = 0x04,    MHL_VC_FEATURE_ID_HID = 0x05,    MHL_VC_FEATURE_ID_END,};enum MHL_VC_RESPONSE_CODE_TYPE{    MHL_VC_RESPONSE_ACCEPT = 0x00,    MHL_VC_RESPONSE_REJECT_NUMBER = 0x01,    MHL_VC_RESPONSE_REJECT_FEATURE_ID = 0x02,    MHL_VC_RESPONSE_REJECT_CHANNEL_SIZE = 0x03,};enum CBUS_DEVCAP_TYPE{    MHL_CBUS_DEV_STATE = 0,    MHL_CBUS_VERSION,    MHL_CBUS_DEV_CAT,    MHL_CBUS_ADOPTER_ID_H,    MHL_CBUS_ADOPTER_ID_L,    MHL_CBUS_VID_LINK_MODE,    MHL_CBUS_AUD_LINK_MODE,    MHL_CBUS_VIDEO_TYPE,    MHL_CBUS_LOG_DEV_MAP,    MHL_CBUS_BANDWIDTH,    MHL_CBUS_FEATURE_FLAG,    MHL_CBUS_DEVICE_ID_H,    MHL_CBUS_DEVICE_ID_L,    MHL_CBUS_SCRATCHPAD_SIZE,    MHL_CBUS_INT_STAT,    MHL_CBUS_RESERVED,    MHL_CBUS_ECBUS_SPEEDS,    MHL_CBUS_TMDS_SPEEDS,    MHL_CBUS_ECBUS_DEV_ROLES,    MHL_CBUS_LOG_DEV_MAPX,};enum MHL_DEVICE_TYPE{    MHL_DEVICE_SINK = 1,    MHL_DEVICE_SOURCE = 2,    MHL_DEVICE_DONGLE = 3,    MHL_DEVICE_DIRECT_ATTACH_SINK = 5,    MHL_DEVICE_DIRECT_ATTACH_SOURCE = 6,};enum MHL_AV_LINK_RATE_TYPE{    MHL_AV_LINK_150 = 0,    MHL_AV_LINK_300,    MHL_AV_LINK_600,    MHL_AV_LINK_NONE,};enum MHL_BIST_AV_LINK_RATE_TYPE{    MHL_BIST_AV_LINK_RESERVED = 0,    MHL_BIST_AV_LINK_150 = 1,    MHL_BIST_AV_LINK_300 = 2,    MHL_BIST_AV_LINK_600 = 3,};enum MHL_BIST_ECBUS_PATTERN_TYPE{    MHL_BIST_ECBUS_PATTERN_RESERVED = 0,    MHL_BIST_ECBUS_PATTERN_PRBS = 1,    MHL_BIST_ECBUS_PATTERN_FIXED8 = 2,    MHL_BIST_ECBUS_PATTERN_FIXED10 = 3,};enum MHL_BIST_LINK_PATTERN_TYPE{    MHL_BIST_LINK_PATTERN_RESERVED = 0,    MHL_BIST_LINK_PATTERN_PRBS = 1,    MHL_BIST_LINK_PATTERN_FIXED8 = 2,    MHL_BIST_LINK_PATTERN_FIXED10 = 3,};enum MHL_BIST_IMPEDANCE_MODE_TYPE{    MHL_BIST_IMPEDANCE_AV_LINK_TX_LOW = 0,    MHL_BIST_IMPEDANCE_AV_LINK_TX_HIGH = 1,    MHL_BIST_IMPEDANCE_AV_LINK_RX = 2,    MHL_BIST_IMPEDANCE_ECBUS_D_TX_LOW = 4,    MHL_BIST_IMPEDANCE_ECBUS_D_TX_HIGH = 5,    MHL_BIST_IMPEDANCE_ECBUS_D_RX = 6,    MHL_BIST_IMPEDANCE_ECBUS_S_TX_LOW = 8,    MHL_BIST_IMPEDANCE_ECBUS_S_TX_HIGH = 9,    MHL_BIST_IMPEDANCE_ECBUS_S_RX = 10,};enum MHL_RAP_KEY_TYPE{    MHL_RAP_KEY_POLL = 0x00,    MHL_RAP_KEY_CONTENT_ON = 0x10,    MHL_RAP_KEY_CONTENT_OFF = 0x11,    MHL_RAP_KEY_CBUS_MODE_DOWN = 0x20,    MHL_RAP_KEY_CBUS_MODE_UP = 0x21,};enum MHL_BURST_ID_TYPE{    MHL_BURST_ID_3D_VIC = 0x0010,    MHL_BURST_ID_3D_DTD = 0x0011,    MHL_BURST_ID_HEV_VIC = 0x0020,    MHL_BURST_ID_HEV_DTDA = 0x0021,    MHL_BURST_ID_HEV_DTDB = 0x0022,    MHL_BURST_ID_VC_ASSIGN = 0x0038,    MHL_BURST_ID_VC_CONFIRM = 0x0039,    MHL_BURST_ID_AUD_DELAY = 0x0040,    MHL_BURST_ID_ADT_BURSTID = 0x0041,    MHL_BURST_ID_BIST_SETUP = 0x0051,    MHL_BURST_ID_BIST_RETURN_STAT = 0x0052,    MHL_BURST_ID_BIST_DISCARD = 0x0053,    MHL_BURST_ID_BIST_ECHO_REQUEST = 0x0054,    MHL_BURST_ID_BIST_ECHO_RESPONSE = 0x0055,    MHL_BURST_ID_EMSC_SUPPORT = 0x0061,    MHL_BURST_ID_HID_PAYLOAD = 0x0062,    MHL_BURST_ID_BLK_RCV_BUFFER_INFO = 0x0063,    MHL_BURST_ID_BITS_PER_PIXEL_FMT = 0x0064,};typedef struct{    MS_BOOL bDCAP_CHG; // 0x20[0], device capability changed    MS_BOOL bDSCR_CHG; // 0x20[1], device scratchpad changed    MS_BOOL bREQ_WRT; // 0x20[2], Request-to-Write    MS_BOOL bGRT_WRT; // 0x20[3], Grant-to-Write    MS_BOOL bEDID_CHG; // 0x21[1], EDID changed} DevIntReg_S;typedef struct{    MS_BOOL bDCAP_RDY; // 0x30[0], device capability ready    MS_U8 CLK_MODE; // 0x31[2:0], MHL clock mode    MS_BOOL bPATH_EN; // 0x31[3], device TMDS path enable    MS_BOOL bMUTED; // 0x31[4], device content stream is muted} DevStatusReg_S;typedef struct{    MS_U8 msgData[MHL_CBUS_DATA_SIZE +1];    // Cbus message data    MS_U8 cmd;    // MSC command    MS_U8 len;    // message length    MS_U8 rcState;    // received state    CbusReqState_T reqStatus;    // Cbus request status} CbusReq_S;typedef struct{    CbusReq_S request[MHL_CBUS_TOTAL_QUEUE_NUM];    //MS_U32 reqWrtTimer;    // Timer for RAP command response    //MS_BOOL bMhlCbusConnected;    // True if a connected MHD port    CbusState_T MhlCbusState;    // MHL Cbus state    MS_U16 timeout;    // Timer for message response (must be able to indicate at least 3000ms).    MS_U8 curIdx;    // current index.    //MS_BOOL bMhlHpdState;    // SET_HPD(TRUE) / CLR_HPD(FALSE)    //MS_BOOL reqWrt;    // request to write peer's scratchpad regs    MS_BOOL bIsCmdinDataField;    // Is command in data field    //DevIntReg_S MhlDevIntReg;    //DevStatusReg_S MhlDevStatusReg;} CbusInfo_S;typedef struct{    MS_U8 ucSystemIndex;    MS_U8 ucCbusIndex; // MHL Cbus status    MS_U8 ucCbusErrorCode;    MS_U8 MhlPowerStatus; // MHL power status    MS_U8 ucAskData;    MS_U8 ucCellPhone;    MS_U8 ucMSGData[2];    MS_U8 ucReceiveCounter;    MS_U8 ucEMSCReceiveCounter;    MS_U8 ucMainLinkRate;    MS_U16 usDisplayIndex;    MS_U16 usCbusS2PatchCnt;    MS_U16 usEMSCRxBufferSize;    MS_U16 usEMSCTxBufferSize;    MS_U32 ulReceiveIndex;    MS_U32 ulSendIndex;    MS_U32 ulRequestIndex;    CbusInfo_S MhlCbusInfo;} MHLInfo_S;typedef struct{    MS_U8 lens;    MS_U16 databuf[DMHL_CBUS_TX_FIFO];} mhalCbusFifo_S;typedef struct{    MS_BOOL bVCConfirm;    MS_U8 ucVCNumber;    MS_U8 ucVCSlotSize;    MS_U8 ucVCResponseCode;    MS_U8 ucVCFeatureID;} ST_VIRTUAL_CHANNEL_INFO;typedef struct{    MS_BOOL bTriggerAVLinkFlag;    MS_U8 ucBISTeCbusPattern;    MS_U8 ucBISTAVLinkPattern;    MS_U8 ucBISTAVLinkRate;    MS_U8 ucBISTAVLinkMode;    MS_U8 ucBISTAVLinkRateRandomizer;    MS_U8 ucBISTImpedanceMode;    MS_U16 usBISTeCbusPatternFixed;    MS_U16 usBISTeCbusDuration;    MS_U16 usBISTeCbusErrorCount;    MS_U16 usBISTAVLinkFixed;    MS_U16 usBISTAVLinkDuration;    MS_U16 usBISTAVLinkErrorCount;} ST_BIST_MODE_INFO;//-------------------------------------------------------------------------------------------------//  Type and Structure//-------------------------------------------------------------------------------------------------enum MHL_SYSTEM_FLAG_TYPE{    MHL_SYSTEM_SENT_CLR_HPD_FLAG = BIT(0),    MHL_SYSTEM_POWER_ON_TIMER_FLAG = BIT(1),    MHL_SYSTEM_FORCE_SEND_COMMAND_FLAG = BIT(2),    MHL_SYSTEM_RECEIVE_LOSE_FLAG = BIT(3),    MHL_SYSTEM_CHECK_CONTENT_ENABLE_FLAG = BIT(4),};enum CBUS_LINK_FLAG_TYPE{    MHL_CBUS_CABLE_PLUG_FLAG = BIT(0),    MHL_CBUS_CONNECT_FLAG = BIT(1),    MHL_CBUS_TIME_OUT_FLAG = BIT(2),    MHL_CBUS_POWER_ON_FLAG = BIT(3),    MHL_ENABLE_CBUS_ENHANCE_FLAG = BIT(4),};enum MHL_CBUS_DISPLAY_FLAG_TYPE{    MHL_CBUS_HPD_SET_FLAG = BIT(0),    MHL_CBUS_PATH_EN_FLAG = BIT(1),    MHL_CBUS_VERSION_CODE_FLAG = BIT(2),    MHL_CBUS_DEVCAP_READY_FLAG = BIT(3),    MHL_CBUS_DEVCAP_CHANGE_FLAG = BIT(4),    MHL_CBUS_LINK_STATUS_NORMAL_FLAG = BIT(5),};enum MHL_RECEIVE_FLAG_TYPE{    MHL_CBUS_RECEIVE_MSC_FLAG = BIT(0),    MHL_CBUS_RECEIVE_ACK_FLAG = BIT(1),    MHL_CBUS_RECEIVE_ABORT_FLAG = BIT(2),    MHL_CBUS_RECEIVE_MSG_FLAG = BIT(3),    MHL_CBUS_RECEIVE_WAKE_FLAG = BIT(4),    MHL_CBUS_RECEIVE_ERROR_FLAG = BIT(5),    MHL_CBUS_RECEIVE_DEVCAP_FLAG = BIT(6),    MHL_CBUS_RECEIVE_XDEVCAP_SUPPORT_FLAG = BIT(7),    MHL_CBUS_RECEIVE_PATH_EN_FLAG = BIT(8),    MHL_CBUS_RECEIVE_MUTED_FLAG = BIT(9),    MHL_CBUS_RECEIVE_MHL3_VERSION_FLAG = BIT(10),    MHL_CBUS_RECEIVE_3D_REQ_FLAG = BIT(11),    MHL_CBUS_RECEIVE_VC_ASSIGN_FLAG = BIT(12),    MHL_CBUS_RECEIVE_FEATURE_REQUEST_FLAG = BIT(13),    MHL_CBUS_RECEIVE_FEATURE_COMPLETE_FLAG = BIT(14),    MHL_CBUS_RECEIVE_LINK_RATE_FLAG = BIT(15),};enum MHL_SEND_FLAG_TYPE{    MHL_CBUS_SEND_ASK_DATA_FLAG = BIT(0),    MHL_CBUS_SEND_ASK_FINISH_FLAG = BIT(1),    MHL_CBUS_SEND_RCP_ENABLE_FLAG = BIT(2),    MHL_CBUS_SEND_RAP_ENABLE_FLAG = BIT(3),    MHL_CBUS_SEND_MSG_FINISH_FLAG = BIT(4),    MHL_CBUS_SEND_MSG_COMMAND_FLAG = BIT(5),    MHL_CBUS_SEND_RCP_RELEASE_ENABLE_FLAG = BIT(6),    MHL_CBUS_SEND_CHECK_CONTENT_ON_FLAG = BIT(7),    MHL_CBUS_SEND_READ_DEVCAP_FLAG = BIT(8),    MHL_CBUS_SEND_GET_VENDER_ID_FLAG = BIT(9),    MHL_CBUS_READ_DEVCAP_ENABLE_FLAG = BIT(10),    MHL_CBUS_READ_XDEVCAP_ENABLE_FLAG = BIT(11),    MHL_CBUS_GET_VENDER_ID_ENABLE_FLAG = BIT(12),    MHL_CBUS_SEND_3D_INFORMATION_FLAG = BIT(13),    MHL_CBUS_SEND_3D_DTD_FLAG = BIT(14),    MHL_CBUS_SEND_3D_VIC_FLAG = BIT(15),    MHL_CBUS_SEND_VC_INFORMATION_FLAG = BIT(16),    MHL_CBUS_SEND_VC_CONFIRM_FLAG = BIT(17),    MHL_CBUS_SEND_HIGH_END_VIDEO_FLAG = BIT(18),    MHL_CBUS_SEND_AUDIO_DATA_TUNNEL_FLAG = BIT(19),    MHL_CBUS_SEND_EMSC_DATA_TUNNEL_FLAG = BIT(20),    MHL_CBUS_SEND_USER_WRITE_BURST_FLAG = BIT(21),    MHL_CBUS_SEND_HEV_VIC_FLAG = BIT(22),    MHL_CBUS_SEND_HEV_DTDA_FLAG = BIT(23),    MHL_CBUS_SEND_HEV_DTDB_FLAG = BIT(24),    MHL_CBUS_SEND_BIST_RETURN_STATUS_FLAG = BIT(25),    MHL_CBUS_SEND_LINK_STATUS_NORMAL_FLAG = BIT(26),};enum MHL_EXTEND_FLAG_TYPE{    CBUS_RECEIVE_3D_REQ_FLAG = BIT(0),    CBUS_SEND_3D_VIC_FLAG = BIT(1),    CBUS_SEND_3D_DTD_FLAG = BIT(2),};enum MHL_CELL_PHONE_FLAG_TYPE{    CELL_PHONE_ROKU_FLAG = BIT(0),    CELL_PHONE_HTC_FLAG = BIT(1),};#define MHL_CBUS_DISPLAY_MASK               (MHL_CBUS_HPD_SET_FLAG |MHL_CBUS_PATH_EN_FLAG |MHL_CBUS_DEVCAP_READY_FLAG)#define MHL_ECBUS_DISPLAY_MASK              (MHL_CBUS_VERSION_CODE_FLAG| MHL_CBUS_DEVCAP_CHANGE_FLAG| MHL_CBUS_LINK_STATUS_NORMAL_FLAG)#define MHL_CBUS_DISPLAY_MASK_SHIFT         8U#define MHL_CBUS_DISPLAY_CHECK_MASK         (MHL_CBUS_DISPLAY_MASK << MHL_CBUS_DISPLAY_MASK_SHIFT)#define MHL_3D_SUPPORT_MASK                 (MHL_3D_FS_SUPPORT |MHL_3D_TB_SUPPORT |MHL_3D_LR_SUPPORT)//-------------------------------------------------------------------------------------------------//  Global Variables//-------------------------------------------------------------------------------------------------extern MHLInfo_S gMHLInfo;extern MS_U8 ucMHLWriteBurstInformation[];//-------------------------------------------------------------------------------------------------//  Macro define//-------------------------------------------------------------------------------------------------#define GET_MHL_SEND_CLR_HPD()              (MS_BOOL)((gMHLInfo.ucSystemIndex & MHL_SYSTEM_SENT_CLR_HPD_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_CLR_HPD()              (gMHLInfo.ucSystemIndex |= MHL_SYSTEM_SENT_CLR_HPD_FLAG)#define CLR_MHL_SEND_CLR_HPD()              (gMHLInfo.ucSystemIndex &= ~MHL_SYSTEM_SENT_CLR_HPD_FLAG)#define GET_MHL_POWER_ON_TIMER()            (MS_BOOL)((gMHLInfo.ucSystemIndex & MHL_SYSTEM_POWER_ON_TIMER_FLAG) ?TRUE :FALSE)#define SET_MHL_POWER_ON_TIMER()            (gMHLInfo.ucSystemIndex |= MHL_SYSTEM_POWER_ON_TIMER_FLAG)#define CLR_MHL_POWER_ON_TIMER()            (gMHLInfo.ucSystemIndex &= ~MHL_SYSTEM_POWER_ON_TIMER_FLAG)#define GET_MHL_FORCE_SEND_COMMAND()        (MS_BOOL)((gMHLInfo.ucSystemIndex & MHL_SYSTEM_FORCE_SEND_COMMAND_FLAG) ?TRUE :FALSE)#define SET_MHL_FORCE_SEND_COMMAND()        (gMHLInfo.ucSystemIndex |= MHL_SYSTEM_FORCE_SEND_COMMAND_FLAG)#define CLR_MHL_FORCE_SEND_COMMAND()        (gMHLInfo.ucSystemIndex &= ~MHL_SYSTEM_FORCE_SEND_COMMAND_FLAG)#define GET_MHL_RECEIVE_LOSE_FLAG()         (MS_BOOL)((gMHLInfo.ucSystemIndex & MHL_SYSTEM_RECEIVE_LOSE_FLAG) ?TRUE :FALSE)#define SET_MHL_RECEIVE_LOSE_FLAG()         (gMHLInfo.ucSystemIndex |= MHL_SYSTEM_RECEIVE_LOSE_FLAG)#define CLR_MHL_RECEIVE_LOSE_FLAG()         (gMHLInfo.ucSystemIndex &= ~MHL_SYSTEM_RECEIVE_LOSE_FLAG)#define GET_MHL_CHECK_CONTENT_ENABLE()      (MS_BOOL)((gMHLInfo.ucSystemIndex & MHL_SYSTEM_CHECK_CONTENT_ENABLE_FLAG) ?TRUE :FALSE)#define SET_MHL_CHECK_CONTENT_ENABLE()      (gMHLInfo.ucSystemIndex |= MHL_SYSTEM_CHECK_CONTENT_ENABLE_FLAG)#define CLR_MHL_CHECK_CONTENT_ENABLE()      (gMHLInfo.ucSystemIndex &= ~MHL_SYSTEM_CHECK_CONTENT_ENABLE_FLAG)#define GET_MHL_CABLE_PLUGGED()             (MS_BOOL)((gMHLInfo.ucCbusIndex & MHL_CBUS_CABLE_PLUG_FLAG) ?TRUE :FALSE)#define SET_MHL_CABLE_PLUGGED()             (gMHLInfo.ucCbusIndex |= MHL_CBUS_CABLE_PLUG_FLAG)#define CLR_MHL_CABLE_PLUGGED()             (gMHLInfo.ucCbusIndex &= ~MHL_CBUS_CABLE_PLUG_FLAG)#define GET_MHL_CBUS_CONNECT()              (MS_BOOL)((gMHLInfo.ucCbusIndex & MHL_CBUS_CONNECT_FLAG) ?TRUE :FALSE)#define SET_MHL_CBUS_CONNECT()              (gMHLInfo.ucCbusIndex |= MHL_CBUS_CONNECT_FLAG)#define CLR_MHL_CBUS_CONNECT()              (gMHLInfo.ucCbusIndex &= ~MHL_CBUS_CONNECT_FLAG)#define GET_MHL_TIME_OUT_FLAG()             (MS_BOOL)((gMHLInfo.ucCbusIndex & MHL_CBUS_TIME_OUT_FLAG) ?TRUE :FALSE)#define SET_MHL_TIME_OUT_FLAG()             (gMHLInfo.ucCbusIndex |= MHL_CBUS_TIME_OUT_FLAG)#define CLR_MHL_TIME_OUT_FLAG()             (gMHLInfo.ucCbusIndex &= ~MHL_CBUS_TIME_OUT_FLAG)#define GET_MHL_PORT_ON_FLAG()              (MS_BOOL)((gMHLInfo.ucCbusIndex & MHL_CBUS_POWER_ON_FLAG) ?TRUE :FALSE)#define SET_MHL_PORT_ON_FLAG()              (gMHLInfo.ucCbusIndex |= MHL_CBUS_POWER_ON_FLAG)#define CLR_MHL_PORT_ON_FLAG()              (gMHLInfo.ucCbusIndex &= ~MHL_CBUS_POWER_ON_FLAG)#define GET_MHL_ENABLE_CBUS_ENHANCE()       (MS_BOOL)((gMHLInfo.ucCbusIndex & MHL_ENABLE_CBUS_ENHANCE_FLAG) ?TRUE :FALSE)#define SET_MHL_ENABLE_CBUS_ENHANCE()       (gMHLInfo.ucCbusIndex |= MHL_ENABLE_CBUS_ENHANCE_FLAG)#define CLR_MHL_ENABLE_CBUS_ENHANCE()       (gMHLInfo.ucCbusIndex &= ~MHL_ENABLE_CBUS_ENHANCE_FLAG)#define GET_MHL_HPD_SET_FLAG()              (MS_BOOL)((gMHLInfo.usDisplayIndex & MHL_CBUS_HPD_SET_FLAG) ?TRUE :FALSE)#define SET_MHL_HPD_SET_FLAG()              (gMHLInfo.usDisplayIndex |= MHL_CBUS_HPD_SET_FLAG)#define CLR_MHL_HPD_SET_FLAG()              (gMHLInfo.usDisplayIndex &= ~MHL_CBUS_HPD_SET_FLAG)#define GET_MHL_DCAP_RDY_FLAG()             (MS_BOOL)((gMHLInfo.usDisplayIndex & MHL_CBUS_DEVCAP_READY_FLAG) ?TRUE :FALSE)#define SET_MHL_DCAP_RDY_FLAG()             (gMHLInfo.usDisplayIndex |= MHL_CBUS_DEVCAP_READY_FLAG)#define CLR_MHL_DCAP_RDY_FLAG()             (gMHLInfo.usDisplayIndex &= ~MHL_CBUS_DEVCAP_READY_FLAG)#define GET_MHL_DCAP_CHG_FLAG()             (MS_BOOL)((gMHLInfo.usDisplayIndex & MHL_CBUS_DEVCAP_CHANGE_FLAG) ?TRUE :FALSE)#define SET_MHL_DCAP_CHG_FLAG()             (gMHLInfo.usDisplayIndex |= MHL_CBUS_DEVCAP_CHANGE_FLAG)#define CLR_MHL_DCAP_CHG_FLAG()             (gMHLInfo.usDisplayIndex &= ~MHL_CBUS_DEVCAP_CHANGE_FLAG)#define GET_MHL_PATH_EN_FLAG()              (MS_BOOL)((gMHLInfo.usDisplayIndex & MHL_CBUS_PATH_EN_FLAG) ?TRUE :FALSE)#define SET_MHL_PATH_EN_FLAG()              (gMHLInfo.usDisplayIndex |= MHL_CBUS_PATH_EN_FLAG)#define CLR_MHL_PATH_EN_FLAG()              (gMHLInfo.usDisplayIndex &= ~MHL_CBUS_PATH_EN_FLAG)#define GET_MHL_VERSION_CODE()              (MS_BOOL)((gMHLInfo.usDisplayIndex & MHL_CBUS_VERSION_CODE_FLAG) ?TRUE :FALSE)#define SET_MHL_VERSION_CODE()              (gMHLInfo.usDisplayIndex |= MHL_CBUS_VERSION_CODE_FLAG)#define CLR_MHL_VERSION_CODE()              (gMHLInfo.usDisplayIndex &= ~MHL_CBUS_VERSION_CODE_FLAG)#define GET_MHL_LINK_STATUS_NORMAL()        (MS_BOOL)((gMHLInfo.usDisplayIndex & MHL_CBUS_LINK_STATUS_NORMAL_FLAG) ?TRUE :FALSE)#define SET_MHL_LINK_STATUS_NORMAL()        (gMHLInfo.usDisplayIndex |= MHL_CBUS_LINK_STATUS_NORMAL_FLAG)#define CLR_MHL_LINK_STATUS_NORMAL()        (gMHLInfo.usDisplayIndex &= ~MHL_CBUS_LINK_STATUS_NORMAL_FLAG)#define GET_CBUS_DISPLAY_FLAG()             (gMHLInfo.usDisplayIndex &BMASK(7:0))#define GET_CBUS_DISPLAY_CHECK()            ((gMHLInfo.usDisplayIndex &BMASK(15:8)) >> MHL_CBUS_DISPLAY_MASK_SHIFT)#define SET_CBUS_DISPLAY_FLAG(a)            (gMHLInfo.usDisplayIndex = a)#define CLR_CBUS_DISPLAY_FLAG()             (gMHLInfo.usDisplayIndex = 0)#define GET_CBUS_DISPLAY_READY()            ((((GET_CBUS_DISPLAY_CHECK() &MHL_CBUS_DISPLAY_MASK) ^MHL_CBUS_DISPLAY_MASK) > 0) ?FALSE :TRUE)#define CLR_CBUS_LINK_FLAG()                (CLR_MHL_CBUS_CONNECT(), CLR_MHL_TIME_OUT_FLAG(), CLR_CBUS_DISPLAY_FLAG())#define CLR_CBUS_CABLE_FLAG()               (CLR_MHL_CABLE_PLUGGED(), CLR_CBUS_LINK_FLAG())#define GET_MHL_CBUS_STATE()                (gMHLInfo.MhlCbusInfo.MhlCbusState)#define SET_MHL_CBUS_STATE(a)               (gMHLInfo.MhlCbusInfo.MhlCbusState = a)#define GET_MHL_RECEIVE_MSC()               (MS_BOOL)((gMHLInfo.ulReceiveIndex & MHL_CBUS_RECEIVE_MSC_FLAG) ?TRUE :FALSE)#define SET_MHL_RECEIVE_MSC()               (gMHLInfo.ulReceiveIndex |= MHL_CBUS_RECEIVE_MSC_FLAG)#define CLR_MHL_RECEIVE_MSC()               (gMHLInfo.ulReceiveIndex &= ~MHL_CBUS_RECEIVE_MSC_FLAG)#define GET_MHL_RECEIVE_ACK()               (MS_BOOL)((gMHLInfo.ulReceiveIndex & MHL_CBUS_RECEIVE_ACK_FLAG) ?TRUE :FALSE)#define SET_MHL_RECEIVE_ACK()               (gMHLInfo.ulReceiveIndex |= MHL_CBUS_RECEIVE_ACK_FLAG)#define CLR_MHL_RECEIVE_ACK()               (gMHLInfo.ulReceiveIndex &= ~MHL_CBUS_RECEIVE_ACK_FLAG)#define GET_MHL_RECEIVE_ABORT()             (MS_BOOL)((gMHLInfo.ulReceiveIndex & MHL_CBUS_RECEIVE_ABORT_FLAG) ?TRUE :FALSE)#define SET_MHL_RECEIVE_ABORT()             (gMHLInfo.ulReceiveIndex |= MHL_CBUS_RECEIVE_ABORT_FLAG)#define CLR_MHL_RECEIVE_ABORT()             (gMHLInfo.ulReceiveIndex &= ~MHL_CBUS_RECEIVE_ABORT_FLAG)#define GET_MHL_RECEIVE_MSG()               (MS_BOOL)((gMHLInfo.ulReceiveIndex & MHL_CBUS_RECEIVE_MSG_FLAG) ?TRUE :FALSE)#define SET_MHL_RECEIVE_MSG()               (gMHLInfo.ulReceiveIndex |= MHL_CBUS_RECEIVE_MSG_FLAG)#define CLR_MHL_RECEIVE_MSG()               (gMHLInfo.ulReceiveIndex &= ~MHL_CBUS_RECEIVE_MSG_FLAG)#define GET_MHL_RECEIVE_WAKE()              (MS_BOOL)((gMHLInfo.ulReceiveIndex & MHL_CBUS_RECEIVE_WAKE_FLAG) ?TRUE :FALSE)#define SET_MHL_RECEIVE_WAKE()              (gMHLInfo.ulReceiveIndex |= MHL_CBUS_RECEIVE_WAKE_FLAG)#define CLR_MHL_RECEIVE_WAKE()              (gMHLInfo.ulReceiveIndex &= ~MHL_CBUS_RECEIVE_WAKE_FLAG)#define GET_MHL_RECEIVE_ERROR()             (MS_BOOL)((gMHLInfo.ulReceiveIndex & MHL_CBUS_RECEIVE_ERROR_FLAG) ?TRUE :FALSE)#define SET_MHL_RECEIVE_ERROR()             (gMHLInfo.ulReceiveIndex |= MHL_CBUS_RECEIVE_ERROR_FLAG)#define CLR_MHL_RECEIVE_ERROR()             (gMHLInfo.ulReceiveIndex &= ~MHL_CBUS_RECEIVE_ERROR_FLAG)#define GET_MHL_RECEIVE_DEVCAP()            (MS_BOOL)((gMHLInfo.ulReceiveIndex & MHL_CBUS_RECEIVE_DEVCAP_FLAG) ?TRUE :FALSE)#define SET_MHL_RECEIVE_DEVCAP()            (gMHLInfo.ulReceiveIndex |= MHL_CBUS_RECEIVE_DEVCAP_FLAG)#define CLR_MHL_RECEIVE_DEVCAP()            (gMHLInfo.ulReceiveIndex &= ~MHL_CBUS_RECEIVE_DEVCAP_FLAG)#define GET_MHL_RECEIVE_XDEVCAP()           (MS_BOOL)((gMHLInfo.ulReceiveIndex & MHL_CBUS_RECEIVE_XDEVCAP_SUPPORT_FLAG) ?TRUE :FALSE)#define SET_MHL_RECEIVE_XDEVCAP()           (gMHLInfo.ulReceiveIndex |= MHL_CBUS_RECEIVE_XDEVCAP_SUPPORT_FLAG)#define CLR_MHL_RECEIVE_XDEVCAP()           (gMHLInfo.ulReceiveIndex &= ~MHL_CBUS_RECEIVE_XDEVCAP_SUPPORT_FLAG)#define GET_MHL_RECEIVE_PATH_EN()           (MS_BOOL)((gMHLInfo.ulReceiveIndex & MHL_CBUS_RECEIVE_PATH_EN_FLAG) ?TRUE :FALSE)#define SET_MHL_RECEIVE_PATH_EN()           (gMHLInfo.ulReceiveIndex |= MHL_CBUS_RECEIVE_PATH_EN_FLAG)#define CLR_MHL_RECEIVE_PATH_EN()           (gMHLInfo.ulReceiveIndex &= ~MHL_CBUS_RECEIVE_PATH_EN_FLAG)#define GET_MHL_RECEIVE_MUTED()             (MS_BOOL)((gMHLInfo.ulReceiveIndex & MHL_CBUS_RECEIVE_MUTED_FLAG) ?TRUE :FALSE)#define SET_MHL_RECEIVE_MUTED()             (gMHLInfo.ulReceiveIndex |= MHL_CBUS_RECEIVE_MUTED_FLAG)#define CLR_MHL_RECEIVE_MUTED()             (gMHLInfo.ulReceiveIndex &= ~MHL_CBUS_RECEIVE_MUTED_FLAG)#define GET_MHL_RECEIVE_MHL3_VERSION()      (MS_BOOL)((gMHLInfo.ulReceiveIndex & MHL_CBUS_RECEIVE_MHL3_VERSION_FLAG) ?TRUE :FALSE)#define SET_MHL_RECEIVE_MHL3_VERSION()      (gMHLInfo.ulReceiveIndex |= MHL_CBUS_RECEIVE_MHL3_VERSION_FLAG)#define CLR_MHL_RECEIVE_MHL3_VERSION()      (gMHLInfo.ulReceiveIndex &= ~MHL_CBUS_RECEIVE_MHL3_VERSION_FLAG)#define GET_MHL_RECEIVE_3D_REQUEST()        (MS_BOOL)((gMHLInfo.ulReceiveIndex & MHL_CBUS_RECEIVE_3D_REQ_FLAG) ?TRUE :FALSE)#define SET_MHL_RECEIVE_3D_REQUEST()        (gMHLInfo.ulReceiveIndex |= MHL_CBUS_RECEIVE_3D_REQ_FLAG)#define CLR_MHL_RECEIVE_3D_REQUEST()        (gMHLInfo.ulReceiveIndex &= ~MHL_CBUS_RECEIVE_3D_REQ_FLAG)#define GET_MHL_RECEIVE_VC_ASSIGN()         (MS_BOOL)((gMHLInfo.ulReceiveIndex & MHL_CBUS_RECEIVE_VC_ASSIGN_FLAG) ?TRUE :FALSE)#define SET_MHL_RECEIVE_VC_ASSIGN()         (gMHLInfo.ulReceiveIndex |= MHL_CBUS_RECEIVE_VC_ASSIGN_FLAG)#define CLR_MHL_RECEIVE_VC_ASSIGN()         (gMHLInfo.ulReceiveIndex &= ~MHL_CBUS_RECEIVE_VC_ASSIGN_FLAG)#define GET_MHL_RECEIVE_FEATURE_REQUEST()   (MS_BOOL)((gMHLInfo.ulReceiveIndex & MHL_CBUS_RECEIVE_FEATURE_REQUEST_FLAG) ?TRUE :FALSE)#define SET_MHL_RECEIVE_FEATURE_REQUEST()   (gMHLInfo.ulReceiveIndex |= MHL_CBUS_RECEIVE_FEATURE_REQUEST_FLAG)#define CLR_MHL_RECEIVE_FEATURE_REQUEST()   (gMHLInfo.ulReceiveIndex &= ~MHL_CBUS_RECEIVE_FEATURE_REQUEST_FLAG)#define GET_MHL_RECEIVE_FEATURE_COMPLETE()  (MS_BOOL)((gMHLInfo.ulReceiveIndex & MHL_CBUS_RECEIVE_FEATURE_COMPLETE_FLAG) ?TRUE :FALSE)#define SET_MHL_RECEIVE_FEATURE_COMPLETE()  (gMHLInfo.ulReceiveIndex |= MHL_CBUS_RECEIVE_FEATURE_COMPLETE_FLAG)#define CLR_MHL_RECEIVE_FEATURE_COMPLETE()  (gMHLInfo.ulReceiveIndex &= ~MHL_CBUS_RECEIVE_FEATURE_COMPLETE_FLAG)#define GET_MHL_RECEIVE_LINK_RATE()         (MS_BOOL)((gMHLInfo.ulReceiveIndex & MHL_CBUS_RECEIVE_LINK_RATE_FLAG) ?TRUE :FALSE)#define SET_MHL_RECEIVE_LINK_RATE()         (gMHLInfo.ulReceiveIndex |= MHL_CBUS_RECEIVE_LINK_RATE_FLAG)#define CLR_MHL_RECEIVE_LINK_RATE()         (gMHLInfo.ulReceiveIndex &= ~MHL_CBUS_RECEIVE_LINK_RATE_FLAG)#define CLR_MHL_RECEIVE_FLAG()              (gMHLInfo.ulReceiveIndex = 0)#define GET_MHL_SEND_ASK_DATA()             (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_SEND_ASK_DATA_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_ASK_DATA()             (gMHLInfo.ulSendIndex |= MHL_CBUS_SEND_ASK_DATA_FLAG)#define CLR_MHL_SEND_ASK_DATA()             (gMHLInfo.ulSendIndex &= ~MHL_CBUS_SEND_ASK_DATA_FLAG)#define GET_MHL_SEND_ASK_FINISH()           (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_SEND_ASK_FINISH_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_ASK_FINISH()           (gMHLInfo.ulSendIndex |= MHL_CBUS_SEND_ASK_FINISH_FLAG)#define CLR_MHL_SEND_ASK_FINISH()           (gMHLInfo.ulSendIndex &= ~MHL_CBUS_SEND_ASK_FINISH_FLAG)#define GET_MHL_SEND_RCP_ENABLE()           (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_SEND_RCP_ENABLE_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_RCP_ENABLE()           (gMHLInfo.ulSendIndex |= MHL_CBUS_SEND_RCP_ENABLE_FLAG)#define CLR_MHL_SEND_RCP_ENABLE()           (gMHLInfo.ulSendIndex &= ~MHL_CBUS_SEND_RCP_ENABLE_FLAG)#define GET_MHL_SEND_RAP_ENABLE()           (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_SEND_RAP_ENABLE_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_RAP_ENABLE()           (gMHLInfo.ulSendIndex |= MHL_CBUS_SEND_RAP_ENABLE_FLAG)#define CLR_MHL_SEND_RAP_ENABLE()           (gMHLInfo.ulSendIndex &= ~MHL_CBUS_SEND_RAP_ENABLE_FLAG)#define GET_MHL_SEND_MSG_FINISH()           (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_SEND_MSG_FINISH_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_MSG_FINISH()           (gMHLInfo.ulSendIndex |= MHL_CBUS_SEND_MSG_FINISH_FLAG)#define CLR_MHL_SEND_MSG_FINISH()           (gMHLInfo.ulSendIndex &= ~MHL_CBUS_SEND_MSG_FINISH_FLAG)#define GET_MHL_SEND_MSG_COMMAND()          (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_SEND_MSG_COMMAND_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_MSG_COMMAND()          (gMHLInfo.ulSendIndex |= MHL_CBUS_SEND_MSG_COMMAND_FLAG)#define CLR_MHL_SEND_MSG_COMMAND()          (gMHLInfo.ulSendIndex &= ~MHL_CBUS_SEND_MSG_COMMAND_FLAG)#define GET_MHL_SEND_RCP_RELEASE_FLAG()     (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_SEND_RCP_RELEASE_ENABLE_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_RCP_RELEASE_FLAG()     (gMHLInfo.ulSendIndex |= MHL_CBUS_SEND_RCP_RELEASE_ENABLE_FLAG)#define CLR_MHL_SEND_RCP_RELEASE_FLAG()     (gMHLInfo.ulSendIndex &= ~MHL_CBUS_SEND_RCP_RELEASE_ENABLE_FLAG)#define GET_MHL_SEND_CHECK_CONTENT_ON()     (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_SEND_CHECK_CONTENT_ON_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_CHECK_CONTENT_ON()     (gMHLInfo.ulSendIndex |= MHL_CBUS_SEND_CHECK_CONTENT_ON_FLAG)#define CLR_MHL_SEND_CHECK_CONTENT_ON()     (gMHLInfo.ulSendIndex &= ~MHL_CBUS_SEND_CHECK_CONTENT_ON_FLAG)#define GET_MHL_SEND_READ_DEVCAP()          (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_SEND_READ_DEVCAP_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_READ_DEVCAP()          (gMHLInfo.ulSendIndex |= MHL_CBUS_SEND_READ_DEVCAP_FLAG)#define CLR_MHL_SEND_READ_DEVCAP()          (gMHLInfo.ulSendIndex &= ~MHL_CBUS_SEND_READ_DEVCAP_FLAG)#define GET_MHL_SEND_GET_VENDER_ID()        (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_SEND_GET_VENDER_ID_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_GET_VENDER_ID()        (gMHLInfo.ulSendIndex |= MHL_CBUS_SEND_GET_VENDER_ID_FLAG)#define CLR_MHL_SEND_GET_VENDER_ID()        (gMHLInfo.ulSendIndex &= ~MHL_CBUS_SEND_GET_VENDER_ID_FLAG)#define GET_MHL_READ_DEVCAP_ENABLE()        (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_READ_DEVCAP_ENABLE_FLAG) ?TRUE :FALSE)#define SET_MHL_READ_DEVCAP_ENABLE()        (gMHLInfo.ulSendIndex |= MHL_CBUS_READ_DEVCAP_ENABLE_FLAG)#define CLR_MHL_READ_DEVCAP_ENABLE()        (gMHLInfo.ulSendIndex &= ~MHL_CBUS_READ_DEVCAP_ENABLE_FLAG)#define GET_MHL_READ_XDEVCAP_ENABLE()       (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_READ_XDEVCAP_ENABLE_FLAG) ?TRUE :FALSE)#define SET_MHL_READ_XDEVCAP_ENABLE()       (gMHLInfo.ulSendIndex |= MHL_CBUS_READ_XDEVCAP_ENABLE_FLAG)#define CLR_MHL_READ_XDEVCAP_ENABLE()       (gMHLInfo.ulSendIndex &= ~MHL_CBUS_READ_XDEVCAP_ENABLE_FLAG)#define GET_MHL_GET_VENDER_ID_ENABLE()      (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_GET_VENDER_ID_ENABLE_FLAG) ?TRUE :FALSE)#define SET_MHL_GET_VENDER_ID_ENABLE()      (gMHLInfo.ulSendIndex |= MHL_CBUS_GET_VENDER_ID_ENABLE_FLAG)#define CLR_MHL_GET_VENDER_ID_ENABLE()      (gMHLInfo.ulSendIndex &= ~MHL_CBUS_GET_VENDER_ID_ENABLE_FLAG)#define GET_MHL_SEND_3D_INFORMATION()       (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_SEND_3D_INFORMATION_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_3D_INFORMATION()       (gMHLInfo.ulSendIndex |= MHL_CBUS_SEND_3D_INFORMATION_FLAG)#define CLR_MHL_SEND_3D_INFORMATION()       (gMHLInfo.ulSendIndex &= ~MHL_CBUS_SEND_3D_INFORMATION_FLAG)#define GET_MHL_SEND_3D_DTD()               (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_SEND_3D_DTD_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_3D_DTD()               (gMHLInfo.ulSendIndex |= MHL_CBUS_SEND_3D_DTD_FLAG)#define CLR_MHL_SEND_3D_DTD()               (gMHLInfo.ulSendIndex &= ~MHL_CBUS_SEND_3D_DTD_FLAG)#define GET_MHL_SEND_3D_VIC()               (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_SEND_3D_VIC_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_3D_VIC()               (gMHLInfo.ulSendIndex |= MHL_CBUS_SEND_3D_VIC_FLAG)#define CLR_MHL_SEND_3D_VIC()               (gMHLInfo.ulSendIndex &= ~MHL_CBUS_SEND_3D_VIC_FLAG)#define GET_MHL_SEND_VC_INFORMATION()       (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_SEND_VC_INFORMATION_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_VC_INFORMATION()       (gMHLInfo.ulSendIndex |= MHL_CBUS_SEND_VC_INFORMATION_FLAG)#define CLR_MHL_SEND_VC_INFORMATION()       (gMHLInfo.ulSendIndex &= ~MHL_CBUS_SEND_VC_INFORMATION_FLAG)#define GET_MHL_SEND_VC_CONFIRM()           (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_SEND_VC_CONFIRM_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_VC_CONFIRM()           (gMHLInfo.ulSendIndex |= MHL_CBUS_SEND_VC_CONFIRM_FLAG)#define CLR_MHL_SEND_VC_CONFIRM()           (gMHLInfo.ulSendIndex &= ~MHL_CBUS_SEND_VC_CONFIRM_FLAG)#define GET_MHL_SEND_HIGH_END_VIDEO()       (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_SEND_HIGH_END_VIDEO_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_HIGH_END_VIDEO()       (gMHLInfo.ulSendIndex |= MHL_CBUS_SEND_HIGH_END_VIDEO_FLAG)#define CLR_MHL_SEND_HIGH_END_VIDEO()       (gMHLInfo.ulSendIndex &= ~MHL_CBUS_SEND_HIGH_END_VIDEO_FLAG)#define GET_MHL_SEND_AUDIO_DATA_TUNNEL()    (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_SEND_AUDIO_DATA_TUNNEL_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_AUDIO_DATA_TUNNEL()    (gMHLInfo.ulSendIndex |= MHL_CBUS_SEND_AUDIO_DATA_TUNNEL_FLAG)#define CLR_MHL_SEND_AUDIO_DATA_TUNNEL()    (gMHLInfo.ulSendIndex &= ~MHL_CBUS_SEND_AUDIO_DATA_TUNNEL_FLAG)#define GET_MHL_SEND_EMSC_DATA_TUNNEL()     (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_SEND_EMSC_DATA_TUNNEL_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_EMSC_DATA_TUNNEL()     (gMHLInfo.ulSendIndex |= MHL_CBUS_SEND_EMSC_DATA_TUNNEL_FLAG)#define CLR_MHL_SEND_EMSC_DATA_TUNNEL()     (gMHLInfo.ulSendIndex &= ~MHL_CBUS_SEND_EMSC_DATA_TUNNEL_FLAG)#define GET_MHL_SEND_USER_WRITE_BURST()     (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_SEND_USER_WRITE_BURST_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_USER_WRITE_BURST()     (gMHLInfo.ulSendIndex |= MHL_CBUS_SEND_USER_WRITE_BURST_FLAG)#define CLR_MHL_SEND_USER_WRITE_BURST()     (gMHLInfo.ulSendIndex &= ~MHL_CBUS_SEND_USER_WRITE_BURST_FLAG)#define GET_MHL_SEND_HEV_VIC()              (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_SEND_HEV_VIC_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_HEV_VIC()              (gMHLInfo.ulSendIndex |= MHL_CBUS_SEND_HEV_VIC_FLAG)#define CLR_MHL_SEND_HEV_VIC()              (gMHLInfo.ulSendIndex &= ~MHL_CBUS_SEND_HEV_VIC_FLAG)#define GET_MHL_SEND_HEV_DTDA()             (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_SEND_HEV_DTDA_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_HEV_DTDA()             (gMHLInfo.ulSendIndex |= MHL_CBUS_SEND_HEV_DTDA_FLAG)#define CLR_MHL_SEND_HEV_DTDA()             (gMHLInfo.ulSendIndex &= ~MHL_CBUS_SEND_HEV_DTDA_FLAG)#define GET_MHL_SEND_HEV_DTDB()             (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_SEND_HEV_DTDB_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_HEV_DTDB()             (gMHLInfo.ulSendIndex |= MHL_CBUS_SEND_HEV_DTDB_FLAG)#define CLR_MHL_SEND_HEV_DTDB()             (gMHLInfo.ulSendIndex &= ~MHL_CBUS_SEND_HEV_DTDB_FLAG)#define GET_MHL_SEND_BIST_RETURN_STATUS()   (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_SEND_BIST_RETURN_STATUS_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_BIST_RETURN_STATUS()   (gMHLInfo.ulSendIndex |= MHL_CBUS_SEND_BIST_RETURN_STATUS_FLAG)#define CLR_MHL_SEND_BIST_RETURN_STATUS()   (gMHLInfo.ulSendIndex &= ~MHL_CBUS_SEND_BIST_RETURN_STATUS_FLAG)#define GET_MHL_SEND_LINK_STATUS_NORMAL()   (MS_BOOL)((gMHLInfo.ulSendIndex & MHL_CBUS_SEND_LINK_STATUS_NORMAL_FLAG) ?TRUE :FALSE)#define SET_MHL_SEND_LINK_STATUS_NORMAL()   (gMHLInfo.ulSendIndex |= MHL_CBUS_SEND_LINK_STATUS_NORMAL_FLAG)#define CLR_MHL_SEND_LINK_STATUS_NORMAL()   (gMHLInfo.ulSendIndex &= ~MHL_CBUS_SEND_LINK_STATUS_NORMAL_FLAG)#define CLR_MHL_SEND_FLAG()                 (gMHLInfo.ulSendIndex = 0)#define GET_MHL_WRITE_BURST_STATE()         (gMHLInfo.ulRequestIndex &BMASK(3:0))#define SET_MHL_WRITE_BURST_STATE(a)        (gMHLInfo.ulRequestIndex = MASKSET(gMHLInfo.ulRequestIndex, a, BMASK(3:0)))#define GET_MHL_RHID_PROCESS_STATE()        ((gMHLInfo.ulRequestIndex &BMASK(7:4)) >> 4)#define SET_MHL_RHID_PROCESS_STATE(a)       (gMHLInfo.ulRequestIndex = MASKSET(gMHLInfo.ulRequestIndex, (a << 4), BMASK(7:4)))#define GET_MHL_RUSB_PROCESS_STATE()        ((gMHLInfo.ulRequestIndex &BMASK(11:8)) >> 8)#define SET_MHL_RUSB_PROCESS_STATE(a)       (gMHLInfo.ulRequestIndex = MASKSET(gMHLInfo.ulRequestIndex, (a << 8), BMASK(11:8)))#define GET_MHL_BIST_PROCESS_STATE()        ((gMHLInfo.ulRequestIndex &BMASK(15:12)) >> 12)#define SET_MHL_BIST_PROCESS_STATE(a)       (gMHLInfo.ulRequestIndex = MASKSET(gMHLInfo.ulRequestIndex, (a << 12), BMASK(15:12)))#define GET_MHL_FEATURE_REQ_STATE()         ((gMHLInfo.ulRequestIndex &BMASK(19:16)) >> 16)#define SET_MHL_FEATURE_REQ_STATE(a)        (gMHLInfo.ulRequestIndex = MASKSET(gMHLInfo.ulRequestIndex, (a << 16), BMASK(19:16)))#define CLR_MHL_REQUEST_STATE_ALL()         (gMHLInfo.ulRequestIndex = 0)#define GET_MHL_ROKU_DEVICE_FLAG()          (MS_BOOL)((gMHLInfo.ucCellPhone & CELL_PHONE_ROKU_FLAG) ?TRUE :FALSE)#define SET_MHL_ROKU_DEVICE_FLAG()          (gMHLInfo.ucCellPhone |= CELL_PHONE_ROKU_FLAG)#define CLR_MHL_ROKU_DEVICE_FLAG()          (gMHLInfo.ucCellPhone &= ~CELL_PHONE_ROKU_FLAG)#define GET_MHL_HTC_PHONE_FLAG()            (MS_BOOL)((gMHLInfo.ucCellPhone & CELL_PHONE_HTC_FLAG) ?TRUE :FALSE)#define SET_MHL_HTC_PHONE_FLAG()            (gMHLInfo.ucCellPhone |= CELL_PHONE_HTC_FLAG)#define CLR_MHL_HTC_PHONE_FLAG()            (gMHLInfo.ucCellPhone &= ~CELL_PHONE_HTC_FLAG)#define CLR_MHL_CELL_PHONE_FLAG()           (gMHLInfo.ucCellPhone = 0)#define GET_MHL_CBUS_QUEUE(a)               (gMHLInfo.MhlCbusInfo.request[a])#define GET_MHL_QUEUE_STATE(a)              (GET_MHL_CBUS_QUEUE(a).reqStatus)#define SET_MHL_QUEUE_STATE(a ,b)           (GET_MHL_CBUS_QUEUE(a).reqStatus = b)#if(DMHL_TIMER_POLLING_INTERVAL)#define GET_MHL_DEBOUNCE_TIMER()            (gMHLInfo.usCbusS2PatchCnt)#define SET_MHL_DEBOUNCE_TIMER(a)           (gMHLInfo.usCbusS2PatchCnt = a)#define DEC_MHL_DEBOUNCE_TIMER()            (gMHLInfo.usCbusS2PatchCnt--)#define GET_MHL_TIMEOUT_TIMER()             (gMHLInfo.MhlCbusInfo.timeout)#define SET_MHL_TIMEOUT_TIMER(a)            (gMHLInfo.MhlCbusInfo.timeout = a)#define DEC_MHL_TIMEOUT_TIMER()             (gMHLInfo.MhlCbusInfo.timeout--)#else#define GET_MHL_DEBOUNCE_TIMER()            (gMHLInfo.usCbusS2PatchCnt)#define SET_MHL_DEBOUNCE_TIMER(a)           (gMHLInfo.usCbusS2PatchCnt = a /DEM_POLLING_DELAY)#define DEC_MHL_DEBOUNCE_TIMER()            (gMHLInfo.usCbusS2PatchCnt--)#define GET_MHL_TIMEOUT_TIMER()             (gMHLInfo.usCbusS2PatchCnt)#define SET_MHL_TIMEOUT_TIMER(a)            (gMHLInfo.usCbusS2PatchCnt = a *1010 /DEM_POLLING_DELAY)#define DEC_MHL_TIMEOUT_TIMER()             (gMHLInfo.usCbusS2PatchCnt--)#endif#define GET_MHL_CBUS_ERROE_CODE()           (gMHLInfo.ucCbusErrorCode)#define SET_MHL_CBUS_ERROE_CODE(a)          (gMHLInfo.ucCbusErrorCode = a)#define GET_MHL_POWER_STATUS()              (gMHLInfo.MhlPowerStatus &BMASK(3:0))#define SET_MHL_POWER_STATUS(a)             (gMHLInfo.MhlPowerStatus = MASKSET(gMHLInfo.MhlPowerStatus, a, BMASK(3:0)))#define GET_MHL_PORT_SELECT()               ((gMHLInfo.MhlPowerStatus &BMASK(7:4)) >>4)#define SET_MHL_PORT_SELECT(a)              (gMHLInfo.MhlPowerStatus = MASKSET(gMHLInfo.MhlPowerStatus, (a <<4), BMASK(7:4)))#define GET_MHL_CBUS_ASK_DATA()             (gMHLInfo.ucAskData)#define SET_MHL_CBUS_ASK_DATA(a)            (gMHLInfo.ucAskData = a)#define GET_MHL_RX_MSG_COMMAND()            (gMHLInfo.ucMSGData[0])#define SET_MHL_RX_MSG_COMMAND(a)           (gMHLInfo.ucMSGData[0] = a)#define GET_MHL_RX_MSG_DATA()               (gMHLInfo.ucMSGData[1])#define SET_MHL_RX_MSG_DATA(a)              (gMHLInfo.ucMSGData[1] = a)#define GET_MHL_RX_RECEIVE_COUNTER()        (gMHLInfo.ucReceiveCounter)#define CLR_MHL_RX_RECEIVE_COUNTER()        (gMHLInfo.ucReceiveCounter = 0)#define INC_MHL_RX_RECEIVE_COUNTER()        (gMHLInfo.ucReceiveCounter++)#define DEC_MHL_RX_RECEIVE_COUNTER()        (gMHLInfo.ucReceiveCounter--)#define GET_MHL_EMSC_RECEIVE_COUNTER()      (gMHLInfo.ucEMSCReceiveCounter)#define CLR_MHL_EMSC_RECEIVE_COUNTER()      (gMHLInfo.ucEMSCReceiveCounter = 0)#define INC_MHL_EMSC_RECEIVE_COUNTER()      (gMHLInfo.ucEMSCReceiveCounter++)#define DEC_MHL_EMSC_RECEIVE_COUNTER()      (gMHLInfo.ucEMSCReceiveCounter--)#define GET_MHL_LINK_RATE()                 (gMHLInfo.ucMainLinkRate)#define SET_MHL_LINK_RATE(a)                (gMHLInfo.ucMainLinkRate = a)#define CLR_MHL_PLUGGED_FLAG()              (CLR_CBUS_CABLE_FLAG(), CLR_MHL_RECEIVE_FLAG(), CLR_MHL_SEND_FLAG(), CLR_MHL_RX_RECEIVE_COUNTER(), CLR_MHL_REQUEST_STATE_ALL(), CLR_MHL_EMSC_RECEIVE_COUNTER())#define CLR_MHL_CONNECT_FLAG()              (CLR_CBUS_LINK_FLAG(), CLR_MHL_RECEIVE_FLAG(), CLR_MHL_SEND_FLAG(), CLR_MHL_RX_RECEIVE_COUNTER(), CLR_MHL_REQUEST_STATE_ALL(), CLR_MHL_EMSC_RECEIVE_COUNTER())#define GET_MHL_WRITE_BURST_LENGTH()        (ucMHLWriteBurstInformation[MHL_MSC_SCRATCHPAD_SIZE])#define SET_MHL_WRITE_BURST_LENGTH(a)       (ucMHLWriteBurstInformation[MHL_MSC_SCRATCHPAD_SIZE] = a)#define GET_MHL_WRITE_BURST_ADDRESS()       (ucMHLWriteBurstInformation[MHL_MSC_SCRATCHPAD_SIZE +1])#define SET_MHL_WRITE_BURST_ADDRESS(a)      (ucMHLWriteBurstInformation[MHL_MSC_SCRATCHPAD_SIZE +1] = a)#define GET_MHL_WRITE_BURST_DATA(a)         (ucMHLWriteBurstInformation[a])#define SET_MHL_WRITE_BURST_DATA(a,b)       (ucMHLWriteBurstInformation[a] = b)#define GET_MHL_EMSC_RX_BUFFER_SIZE()       (gMHLInfo.usEMSCRxBufferSize)#define SET_MHL_EMSC_RX_BUFFER_SIZE(a)      (gMHLInfo.usEMSCRxBufferSize = a)#define GET_MHL_EMSC_TX_BUFFER_SIZE()       (gMHLInfo.usEMSCTxBufferSize)#define SET_MHL_EMSC_TX_BUFFER_SIZE(a)      (gMHLInfo.usEMSCTxBufferSize = a)#ifdef __cplusplus}#endif#endif //_MDRV_MHL_ST_H_